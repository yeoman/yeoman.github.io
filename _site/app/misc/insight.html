<h1>Yeoman Insight</h1>

<h2>Overview</h2>

<p>Yeoman Insight is the metrics reporting tool used by the Yeoman CLI to record and report aggregated usage of the project. From day one (ground zero), we aim to be metrics driven. Having insight into what people are doing with our tool will help measure success of the project and steer its future direction.</p>

<h2>Things to measure</h2>

<p>There are a number of useful questions we can answer with good metrics:</p>

<ul>
<li>number of downloads

<ul>
<li>Users install Yeoman from the command line (<code>$ curl -L get.yeoman.io | bash</code>). We record a &quot;download&quot; page view when the CLI is run for the first time. This is essentially equivalent to the # of installs. Users are unlikely to run the install command and never execute a yeoman task.</li>
<li><em>Note: Github does not provide a way to track # of .zip/.tar.gz downloads from the project page.</em></li>
</ul></li>
<li>7, 14, 30-day actives</li>
<li>How many people created a project in the last 30 days?</li>
<li>What commands/actions are most useful? Which are least popular?</li>
<li>What locales are using the tool?</li>
<li>How long does it take for developers to upgrade to a new version?</li>
<li>What JS frameworks are people using?</li>
<li>Imagine: We just launched Yeoman v2.0 @ AwesomeConf JS 2013. Of course it was picked up by Hacker News! Pssht. But...how many new installs did we drive?</li>
</ul>

<p>Turns out, <a href="http://www.google.com/analytics/">Google Analytics</a> is excellent at handling all of these cases.</p>

<h2>Collection Workflow</h2>

<h3>Backend</h3>

<p>Google Analytics suits most of our needs. It was designed to allow any type of app (mobile, non-web page properties, installed apps, etc.) to send data to Analytics for processing. It works similar to the existing API, with the exception that cookies are no longer required.</p>

<p>There are a many benefits to using Analytics instead of rolling our own collecting server on App Engine. Perhaps the biggest: not having to process data ourselves.</p>

<h3>yeomaninsight.py</h3>

<p><code>yeomaninsight.py</code> is the brains behind the operation, located in the <code>/cli/bin</code> folder:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">├── bin
│   └── yeomaninsight.py
│   └── …
</code></pre></div>
<blockquote>
<p><em>Note: /metrics was originally setup as an App Engine Python app before Analytics was chosen as backend. At this time, we don&#39;t need a separate server but the code is intact if/when we decide to build a dashboard for Yeoman.</em></p>
</blockquote>

<p>This script is installed globally as an alias <code>_yeomaninsight</code> to prevent users from a.) seeing the script via auto completing &quot;yeoman*&quot; and b.) mitigating running the script directly.  The script is responsible for collecting, stashing, and sending usage data to Google Analytics.</p>

<p><code>_yeomaninsight</code> is invoked by <code>/cli/lib/plugins/insight.py</code>, which creates a folder in the home directory (<code>~/.yeoman/insight/</code>) when the cli is run for the first time and prompts the user to opt-in to sending anonymous metrics.</p>

<h3>Recording actions</h3>

<p>When users run Yeoman CLI commands, the CLI captures the [sub]commands that were issued by calling <code>yeomaninsight.py</code>&#39;s record API. The installed package version and name are also passed as flags. yeomaninsight.py then writes the task to an offline logfile named .log (created on first-run of <code>yeomaninsight.py</code>).  The format of the file is:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">CLIENTID
TIMESTAMP command
TIMESTAMP command subcommand
…
</code></pre></div>
<p>This file is created and saved to the user&#39;s home directory (<code>~/.yeoman/insight/.log</code>).</p>

<h4>Example run:</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ yeoman init
    -&gt; calls &quot;_yeomaninsight -n yeoman -v 0.9.3 record init&quot;
</code></pre></div>
<p>This creates .log, logs the download on first run, and appends the command:</p>

<table>
<tr><td>Directory structure</td><td>.log</td></tr>
<tr><td><pre>
├── ~/.yeoman/insight/
│   └── .log
</pre></td><td>
<pre>
1336617026.860.421519437366
1336617031.37 /downloaded
1336617031.37 /init
</pre>
</td></tr>
</table>

<p>Running a more complicated command also works:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ yeoman add model MyModel
    -&gt; calls &quot;_yeomaninsight.py -n yeoman -v 0.9.3 record add model myModel&quot;

.log contains:
1336617026.860.421519437366
1336630501.37 /add/model
</code></pre></div>
<p>Notice that</p>

<ol>
<li>Space separated commands are joined by &quot;/&quot;s to form a fake URL path. This simulates a pageview to record in Analytics.</li>
<li>Personalized information like the name of the model being created  (&quot;myModel&quot;) is not recorded or sent.</li>
</ol>

<h4>Why a log file?</h4>

<p>The alternative to stashing actions in .log would be to send live requests to Analytics as commands were issued. The main drawback with that approach is that the tool cannot be used offline. I want to use Yeoman on a plane, bro!</p>

<h3>Sending data</h3>

<p><code>yeomaninsight.py</code> is also responsible for sending the log data to Analytics. We attempt to send data on every command that is run. If a connection is not present, the data is logged to .log and continues to stash until a successful request to Analytics is made. This potentially means that someone could run the CLI once and not use it again for a few hours. That&#39;s ok. The timestamp in the log file is sent with the request to Analytics, allowing it to correctly process older results.</p>

<blockquote>
<p><em>Note: Analytics has a maximum of 24hrs that you can send past data. If a user has data and runs yeoman after this period is up, we&#39;ll lose those actions. There&#39;s nothing that can be done about this. It&#39;s a limitation of the Analytic backend.</em></p>
</blockquote>

<p>After a entries are processed, they&#39;re immediately removed from the log file.</p>

<h4>Analytics request format</h4>

<p>A command is recorded as a &quot;pageview&quot; in Analytics. yeomaninsight.py makes GET requests to the Analytics endpoint, with the relevant parameters included.</p>

<h4>Example</h4>

<p>Eric fires up Yeoman for the first time in 4hrs and runs a few commands:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ yeoman install jquery
    -&gt; calls &quot;_yeomaninsight.py -n yeoman -v 0.9.3 record install jquery&quot;
$ yeoman install angular
    -&gt; calls &quot;_yeomaninsight.py -n yeoman -v 0.9.3 record install angular&quot;
</code></pre></div>
<p>The CLI logs each of these entries and sends them to Analytics. This kicks off a call to <code>_send_all()</code>, which uploads everything in the log file. If the user is offline ((the first request to Analytics fails) when the upload is triggered, existing log data is kept intact until the next run of the CLI when they&#39;re online.</p>

<p>Once all data is sent, <code>.log</code> is scrubbed clean of past data, although the Client ID is preserved:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">1336617026.860.421519437366
</code></pre></div>
<h3>Privacy</h3>

<p>Our implementation uses Google Analytics. See their <a href="http://www.google.com/analytics/learn/privacy.html">TOS/Privacy Policy</a> (e.g. Google&#39;s Privacy Policy) for more information. There are a few points worth calling out:</p>

<ul>
<li>Recording stats are opt-out. This is determined on first-run of the CLI.</li>
<li>We eventually plan to open up the collected data to the public. Everyone will benefit!! We plan to have a metrics dashboard where folks can see the data, as collected by the tool.</li>
<li>The Client ID is generated as combination of timestamp + random_number and is in no way tied to personal data like IP address, name, location, or other personally identifiable information. Google Analytics uses this data (in aggregate) in order to differentiate users of an app. It allows us to answer the question: &quot;# of 7 day active users&quot;.</li>
<li>Data is sent to Analytics, an aggregate collection service. There will be no way for us to see information on any one person.</li>
<li>We are not recording names of things that were created (e.g. someone&#39;s model name, file naming conventions, etc.)</li>
</ul>
